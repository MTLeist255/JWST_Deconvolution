# 2022 June 13: Code used to deconvolve an observed image with the non-circulant Richardson-Lucy algorithm
# import convenience functions
from astropy.visualization import ImageNormalize, MinMaxInterval, SqrtStretch, LogStretch
from photutils import FittableImageModel

from Convenience_Functions import *

# display the deconvolved image?
display = True
# set the number of iterations
iter = 26
# Set the filter
filter = ['F1500W']
# set the model type
model_type = ['standard']
#*********************************************************************************************************************#
for k in range(0, int(len(filter))):
    model = model_type[k]
    # set the importpath for the observed image
    im_path = 'Images/JWST/2_MIRISim_outputs/Deconvolution_testing/Residual_outputs/FITS/Ideal_Model/Model_AGN_complicated/current_12Aug2023/'+str(model)+'/checks/'
    # set the path for the reference psf
    psf_path = 'Images/JWST/1_Input_Models/PSFs/'
    # set the output path for the deconvolved image FITS file
    out_path = 'Images/JWST/4_Deconvolution/1_Richardson_Lucy/FITS/Ideal_Model/Model_AGN_complicated/current_12Aug2023/'+str(model)+'/'

    for i in range(0, int(len(filter))):
        filt = filter[i]
        # set the observation wavelength
        # set the observed wavelength
        if i == 0:
            obs_wave = 15
        elif i == 1:
            obs_wave = 10
        elif i == 2:
            obs_wave = 15
        elif i == 3:
            obs_wave = 18
        else:
            obs_wave = 21

        print(int(obs_wave))
        # Read in the observed image
        #image = get_pkg_data_filename(im_path + str(filt) + '_'+str(model)+'_model.fits')
        image = get_pkg_data_filename(im_path + 'img_complex.fits')

        # read in image data for deconvolution and saving
        image_list = fits.open(image)
        image_data = image_list[0].data

        # copy the primary header information
        sci_hdr = image_list[0].header.copy()

        #plt.imshow(image_data, origin='lower', norm=ImageNormalize(stretch=LogStretch(), vmin=0, vmax=image_data.max()), cmap='RdYlBu_r')
        #plt.title(str(filt) + ' ' + str(model) + ' model', fontsize=20)
        #plt.show()
        # ********************************************************************#

        # set the reference PSF
        # 1) Generated by calcPSF
        # 2) Generated by WebbPSF
        # 3) user generated
        calc_psf = 'Reference_PSFs/calcPSF_reference_PSF_' + str(int(obs_wave)) + 'um.fits'
        webb_psf = 'Reference_PSFs/OVERSAMP_4/WebbPSF_reference_PSF_' + str(int(obs_wave)) + 'um.fits'
        user_psf = 'Test_PSFs/2dgauss_fwhm5_PSF.fits'
        resize_psf = 'Reference_PSFs/JWST_MIRI_resize_obs_' + str(int(obs_wave)) + 'um_TRIM213.fits'
        test_psf = 'Reference_PSFs/JWST_MIRI_5um_OVERSAMP_Test.fits'

        # Read in the reference PSF
        #ref_psf = get_pkg_data_filename(psf_path + webb_psf)
        ref_psf = get_pkg_data_filename(psf_path + webb_psf)

        # read in image data for deconvolution
        psf_list = fits.open(ref_psf)
        # ext 0- SAMP_PSF: PSF binned to detector sampling
        # ext 1- DET_SAMP: PSF binned to detector sampling
        # ext 2- OVERDIST: PSF modified based on detector geometric distortions
        # ext 3- DET_DIST: PSF modified based on detector geometric distortions binned to detector sampling <- USE ME
        psf = psf_list[3].data

        # convert DN/s -> mJy/sr?
        #psf = psf* 0.42818

        # ******************************************* Richardson-Lucy *********************************************************#
        # Deconvolve the observed image using Richardson-Lucy, saving the deconvolved images
        decon_im = []
        # set the number of deconvolution iterations: range(starting value, ending value, incrementing value)
        for j in range(1, iter, 1):
            # richardson_lucy_np(observation, PSF, regularization parameter)
            deconvolution = richardson_lucy_np(image_data, psf, j)
            decon_im.append(deconvolution)

        # ******************************************* Save deconvolved images to FITS file **********************************#
        # save the observed image and deconvolved images to a single FITS file
        image = [image_data] + decon_im

        # save outputs to single FITS file with appropriate FITS header information
        base_filename = str(filt) + '_'+str(model)+'_model.fits'
        outfile = os.path.join(out_path, base_filename)
        hdu = fits.HDUList()

        count = 0
        for k in image:

            if count == 0:
                hdu.append(fits.PrimaryHDU(header=sci_hdr))

            elif count == 1:
                # copy the SCI extension header information
                sci_hdr['BUNIT'] = 'DN'
                sci_hdr[''] = ' and Deconvolution Parameters'
                sci_hdr['MODTYPE'] = ('Model: ', str(model))
                sci_hdr['PIXELSCL'] = (0.111, 'pixel scale')
                sci_hdr['WAVELEN'] = (obs_wave, 'Observed wavelength')
                sci_hdr['FILTER'] = (str(filt), 'Observation filter')
                sci_hdr['INSTRUM'] = ('MIRI', 'Observation instrument')
                sci_hdr['METHOD'] = ('Richardson-Lucy', 'Deconvolution method')
                sci_hdr['ITERATS'] = (str(iter), 'Number of iterations')
                hdu.append(fits.ImageHDU(image[count - 1], header=sci_hdr))

            else:
                # append each deconvolved image
                hdu.append(fits.ImageHDU(image[count - 1], header=sci_hdr))

            count += 1

        #hdu.writeto(outfile, overwrite=True)
        image_list.flush()

        if display:
            # plot for testing
            for l in range(0, int(len(image))):
                image1 = image[l]
                # print('image sum/max: ', image1.sum(), image1.max())
                title = str('iteration: ' + str(l))
                im = plt.imshow(image1, origin='lower',norm=ImageNormalize(stretch=LogStretch(), vmin=0, vmax=image1.max()), cmap='afmhot')
                plt.title(title)
                plt.text(40,20, str(l) + ' Iterations', fontsize=30, color='w', weight='bold')
                #add_colorbar(im, label='Aperture flux (Counts/pixel)')
                plt.savefig(str(l) + '_iter.png')
                plt.show()

# close image imports
image_list.close()
psf_list.close()